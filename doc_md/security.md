**Security: How SchoolPass & Password hashing works**

- **สรุปสั้น ๆ:** ระบบใช้ฟังก์ชันแปลงค่า (one-way hash) โดยอาศัย Web Crypto API (PBKDF2 + SHA-256) เพื่อเก็บค่า `SchoolPass` และ `Password` ในรูปที่ถอดรหัสกลับไม่ได้ (irreversible). ค่าที่เก็บเป็นสตริงรูปแบบ `<saltHex>$<hashHex>` โดยตอนนี้โปรเจกต์ตั้งให้เก็บ hash ส่วนท้ายเป็น 8 ตัวอักษร (hex) ตามที่ร้องขอ.

**1) วิธีการทำงาน (เทคนิคสั้น ๆ)**
- ใช้ PBKDF2 กับค่า input (เช่น รหัสผู้ใช้) ร่วมกับ *salt* แบบสุ่ม 16 ไบต์ และอาศัย SHA-256 เป็นฟังก์ชันแฮช
- ใช้จำนวนรอบการคำนวณ (iterations) เริ่มต้นที่ 100000 เพื่อเพิ่มความยากในการโจมตีด้วย brute-force
- ผลลัพธ์ (derived bits) แปลงเป็น hex แล้วตัด (truncate) ส่วนท้ายเป็นจำนวน hex ที่กำหนด (ปัจจุบันใช้ 8 hex chars)
- เก็บในฐานข้อมูลเป็นสตริง: `<saltHex>$<truncatedHashHex>` (ตัวอย่าง: `9f0a1b...c3d$5f2a9b0c`)

**2) ถอดรหัสได้ไหม?**
- ไม่สามารถถอดกลับเป็น plaintext ได้ (one-way). PBKDF2 เป็นฟังก์ชันการหาอนุพันธ์ที่ออกแบบมาให้ไม่ย้อนกลับโดยตรง
- สิ่งที่เป็นไปได้คือการตรวจสอบค่า (verify): เมื่อผู้ใช้ป้อนค่า ระบบคำนวณ PBKDF2 ด้วย salt เดียวกันแล้วเปรียบเทียบ prefix/ส่วนที่ตัดไว้กับค่าที่เก็บ

**3) รูปแบบที่เก็บและการตรวจสอบ**
- รูปแบบ: `<saltHex>$<hashHex>` (salt fixed length 32 hex chars, hashHex ปัจจุบันสั้น = 8 hex chars)
- การตรวจสอบจะนำค่า plaintext ที่ป้อนมาคำนวณ derived hash เต็มรูปแบบ แล้วเปรียบเทียบเฉพาะ prefix ยาวเท่าที่เก็บไว้ (รองรับการเก็บ hash แบบตัดทอน)

**4) ข้อดี**
- ไม่เก็บ plaintext ⇒ ถ้า DB ถูกเข้าถึงโดยผู้ไม่หวังดี ข้อมูลเดิมไม่สามารถอ่านออกเป็นรหัสจริงได้
- PBKDF2 + salt + high iterations ทำให้การโจมตีแบบ brute-force ช้าลงมาก
- ใช้ Web Crypto API (built-in browser) ไม่มี dependency ภายนอก

**5) ข้อเสีย / ข้อจำกัดที่สำคัญ**
- การตัด hash ให้สั้นเหลือ 8 hex chars (4 bytes) ทำให้ความแข็งแรงของ hash ลดลงมาก — มีความเสี่ยงสูงต่อการชนกัน (collision) และ brute-force
- truncated hash ทำให้ความมั่นใจในการยืนยันค่าน้อยลงเมื่อเทียบกับการเก็บ hash เต็มความยาว (เช่น 32/64 hex)
- PBKDF2 ยังขึ้นกับ iterations — ค่าเล็กเกินไปจะอ่อนแอต่อการโจมตี
- หากต้องการย้อนคืน plaintext จริง ๆ จะทำไม่ได้ — ซึ่งเป็นคุณสมบัติ (design) แต่หมายความว่าถ้าต้องการส่งคืนรหัสให้ผู้ใช้ จะต้องออกแบบ flow เปลี่ยนรหัสแทนการถอดรหัส

**6) คำแนะนำ / ทางเลือกที่ปลอดภัยกว่า**
- เพื่อความปลอดภัยในสภาพแวดล้อม production แนะนำอย่างน้อย: salt 16 bytes (ใช้อยู่แล้ว), iterations สูงขึ้น (>= 100k), และเก็บ hash ยาวกว่ามาก (เช่น 32–64 hex)
- ถ้าต้องการประนีประนอมระหว่างขนาดกับความปลอดภัย ให้ใช้อย่างน้อย 32 hex (16 bytes) แทน 8 hex
- พิจารณาใช้ algorithms ที่ออกแบบมาสำหรับรหัสผ่านเช่น Argon2 หากต้องการความปลอดภัยสูงสุด (ต้องเพิ่ม dependency/native support)

**7) Migration note**
- ปัจจุบันโค้ดจะไม่แปลงค่า plaintext เดิมโดยอัตโนมัติ ยกเว้นเมื่อมีการบันทึก/อัพเดตผ่านฟังก์ชัน `writeFirstTimeSetup` หรือ `completeFirstTimeSetup` ซึ่งจะทำการ hash หากค่าไม่อยู่ในรูป hashed อยู่แล้ว
- ถ้าต้องการแปลงค่าที่มีอยู่ใน DB ให้เป็นรูป hashed แบบใหม่ ผมสามารถเพิ่ม migration startup routine ที่ตรวจสอบค่า plaintext เดิมและเขียนกลับเป็น hashed (one-time)

**8) ตัวอย่างสั้น ๆ (พฤติกรรมโค้ด)**
- เก็บ: `SchoolPass` → `hashValue( schoolPassUppercased, 100000, 8 )` → เก็บ `<salt>$<8hex>`
- ตรวจสอบ: อ่าน `<salt>$<8hex>` → คำนวณ PBKDF2 กับ salt เดิม → เปรียบเทียบ prefix ของ derived hex กับ `<8hex>`

หากต้องการ ผมจะเพิ่มส่วนตัวอย่างคำสั่ง/โค้ดสั้น ๆ ที่อธิบายวิธีเรียก `verifyValue()` หรือเพิ่ม migration อัตโนมัติได้ — ต้องการให้ผมเสริมไหม?

***End of document***
